// $ANTLR 2.7.7 (2006-11-01): "verilog.g" -> "VerilogParser.java"$
package com.simplifide.base.verilog.parse.grammar.verilog;


import com.simplifide.base.sourcefile.antlr.tok.*;



public interface VerilogTokenTypes {
	int EOF = 1;
	int NULL_TREE_LOOKAHEAD = 3;
	int ROOT = 4;
	int DESIGNUNIT = 5;
	int CONTEXTCLAUSE = 6;
	int CONTEXTITEM = 7;
	int DEFINEDIRECTIVE = 8;
	int INCLUDEDIRECTIVE = 9;
	int MODULE = 10;
	int MODULEHEAD = 11;
	int MODULEBODY = 12;
	int MODULEITEM = 13;
	int MODULEDEC = 14;
	int MODULENAME = 15;
	int PORTCLAUSE = 16;
	int PORTLIST = 17;
	int PORTELEMENT = 18;
	int PORTTOP = 19;
	int PORT = 20;
	int PORTNODOT = 21;
	int PORTDOT = 22;
	int PORTEXPRESSION = 23;
	int VARDEC = 24;
	int VARTYPE = 25;
	int VARRANGE = 26;
	int VARLIST = 27;
	int VARNAME = 28;
	int REGMEM = 29;
	int REGMEMARRAY = 30;
	int PARDEC = 31;
	int PARASSIGN = 32;
	int CONTINUOUS_ASSIGN = 33;
	int ASSIGNLIST = 34;
	int ASSIGNMENT = 35;
	int IDENTRANGE = 36;
	int SEGMENTRANGE = 37;
	int QUESTTOP = 38;
	int QUESTIONSEGMENT = 39;
	int PAROP = 40;
	int UNOP = 41;
	int BINOP = 42;
	int BINOPSMALL = 43;
	int CONCAT = 44;
	int ALWAYSTOP = 45;
	int ALWAYSHEAD = 46;
	int EVENTCONTROL = 47;
	int EVENTEXPRESSION = 48;
	int EVENTEXPRESSIONSUB = 49;
	int TOTALASSIGN = 50;
	int CONDITIONTOP = 51;
	int CONDITIONHEAD = 52;
	int CONDITIONELSE = 53;
	int CASETOP = 54;
	int CASEHEAD = 55;
	int CASELIST = 56;
	int CASEEXPRESSION = 57;
	int CASENORMAL = 58;
	int CASEDEFAULT = 59;
	int BEGENDBLOCK = 60;
	int SEQBLOCKNAMEQ = 61;
	int STATELIST = 62;
	int MODITEM = 63;
	int MODINSTANCETOP = 64;
	int MODINSTANCE = 65;
	int INSTANCENAME = 66;
	int INSTANCEPORTLIST = 67;
	int INSTANCEPORT = 68;
	int PORTCON = 69;
	int IDENTIFIERPATH = 70;
	int NAME = 71;
	int NAMERANGE = 72;
	int NAMEDOT = 73;
	int NAMEEXPRESSION = 74;
	int NAMEPOUNDEXPRESSION = 75;
	int DRIVESTRENGTHQ = 76;
	int DELAYQ = 77;
	int DELAYOREVENTCONTROLQ = 78;
	int TASK = 79;
	int FUNCTION = 80;
	int TASKVARDECLARATION = 81;
	int FUNCTIONVARDECLARATION = 82;
	int RANGEORTYPE = 83;
	int PARAMETEROVERRIDE = 84;
	int IFDEFDIRECTIVE = 85;
	int IFDEFHEAD = 86;
	int IFDEFCOND = 87;
	int TIMESCALEDIRECTIVE = 88;
	int TICKIFDEF = 89;
	int TICKIFNDEF = 90;
	int TICKELSE = 91;
	int TICKENDIF = 92;
	int TICKDEFINE = 93;
	int TICKINCLUDE = 94;
	int TICKTIMESCALE = 95;
	int TICKUNDEF = 96;
	int GENERATEITEM = 97;
	int RANGEPARAM = 98;
	int PRIMITIVEDEFINITION = 99;
	int TABLEDEFINITION = 100;
	int SPECIFYBLOCK = 101;
	int SPECIFYITEM = 102;
	int SPECPARAMDECLARATION = 103;
	int PATHDECLARATION = 104;
	int EDGESENSITIVEPATHDECLARATION = 105;
	int SDPD = 106;
	int SIMPLEPATHDECLARATION = 107;
	int PARALLELPATHDECLARATION = 108;
	int FULLPATHDESCRIPTOR = 109;
	int LEVELSENSITIVEPATHDECLARATION = 110;
	int RANGEORTYPEQ = 111;
	int AUTOMATICQ = 112;
	int PREBLOCKNAMEQ = 113;
	int UNIQUEPRIORITY = 114;
	int MATCHES = 115;
	int NAMECOLON = 116;
	int INITIALORFINAL = 117;
	int WAITSTATEMENT = 118;
	int DISABLESTATEMENT = 119;
	int LITERAL_endmodule = 120;
	int LITERAL_module = 121;
	int LITERAL_macromodule = 122;
	int SEMI = 123;
	int LPAREN = 124;
	int RPAREN = 125;
	int COMMA = 126;
	int LBRACE = 127;
	int RBRACE = 128;
	int LBRACK = 129;
	int COLON = 130;
	int RBRACK = 131;
	int LITERAL_generate = 132;
	int LITERAL_endgenerate = 133;
	// "1'b0" = 134
	// "1'b1" = 135
	// "1'bx" = 136
	int NUMBER = 137;
	int LITERAL_primitive = 138;
	int LITERAL_endprimitive = 139;
	int LITERAL_table = 140;
	int LITERAL_endtable = 141;
	int LITERAL_task = 142;
	int LITERAL_endtask = 143;
	int LITERAL_function = 144;
	int LITERAL_endfunction = 145;
	int LITERAL_automatic = 146;
	int LITERAL_integer = 147;
	int LITERAL_real = 148;
	int LITERAL_QQQQQDDDDDEEEEEEEFFFFFFFf = 149;
	int LITERAL_PPPPPQQDDDDDEEEEEEEFFFFFFFf = 150;
	int ASSIGN = 151;
	int LITERAL_tri = 152;
	// "tri1" = 153
	// "supply0" = 154
	int LITERAL_wand = 155;
	int LITERAL_triand = 156;
	// "tri0" = 157
	// "supply1" = 158
	int LITERAL_wor = 159;
	int LITERAL_trior = 160;
	int LITERAL_trireg = 161;
	int LITERAL_scalared = 162;
	int LITERAL_vectored = 163;
	int LITERAL_assign = 164;
	int LITERAL_defparam = 165;
	int LITERAL_small = 166;
	int LITERAL_medium = 167;
	int LITERAL_large = 168;
	// "strong0" = 169
	// "pull0" = 170
	// "weak0" = 171
	// "highz0" = 172
	// "strong1" = 173
	// "pull1" = 174
	// "weak1" = 175
	// "highz1" = 176
	int DOLLAR = 177;
	int PLUS = 178;
	int MINUS = 179;
	int LITERAL_and = 180;
	int LITERAL_nand = 181;
	int LITERAL_or = 182;
	int LITERAL_nor = 183;
	int LITERAL_xor = 184;
	int LITERAL_xnor = 185;
	int LITERAL_buf = 186;
	// "bufif0" = 187
	// "bufif1" = 188
	int LITERAL_not = 189;
	// "notif0" = 190
	// "notif1" = 191
	int LITERAL_pulldown = 192;
	int LITERAL_pullup = 193;
	int LITERAL_nmos = 194;
	int LITERAL_rnmos = 195;
	int LITERAL_pmos = 196;
	int LITERAL_rpmos = 197;
	int LITERAL_cmos = 198;
	int LITERAL_rcmos = 199;
	int LITERAL_tran = 200;
	int LITERAL_rtran = 201;
	// "rtranif0" = 202
	// "tranif1" = 203
	// "rtranif1" = 204
	int POUND = 205;
	int DOT = 206;
	int LITERAL_initial = 207;
	int LITERAL_final = 208;
	int LITERAL_always = 209;
	int LITERAL_always_latch = 210;
	int LITERAL_always_comb = 211;
	int LITERAL_always_ff = 212;
	int LITERAL_if = 213;
	int LITERAL_else = 214;
	int LITERAL_unique = 215;
	int LITERAL_priority = 216;
	int LITERAL_matches = 217;
	int LITERAL_endcase = 218;
	int LITERAL_default = 219;
	int LITERAL_case = 220;
	int LITERAL_casez = 221;
	int LITERAL_casex = 222;
	int LITERAL_forever = 223;
	int LITERAL_repeat = 224;
	int LITERAL_while = 225;
	int LITERAL_for = 226;
	int LITERAL_wait = 227;
	int TRIGGER = 228;
	int LITERAL_disable = 229;
	int LITERAL_begin = 230;
	int LITERAL_end = 231;
	int LITERAL_fork = 232;
	int LITERAL_join = 233;
	int LITERAL_deassign = 234;
	int LITERAL_force = 235;
	int LITERAL_release = 236;
	int LITERAL_specify = 237;
	int LITERAL_endspecify = 238;
	int LITERAL_specparam = 239;
	int PPATH = 240;
	int FPATH = 241;
	// "$setup" = 242
	// "$hold" = 243
	// "$period" = 244
	// "$width" = 245
	// "$skew" = 246
	// "$recovery" = 247
	// "$setuphold" = 248
	// "&&&" = 249
	int LITERAL_posedge = 250;
	int LITERAL_negedge = 251;
	int LITERAL_edge = 252;
	// "0x" = 253
	// "1x" = 254
	int IDENTIFIER = 255;
	int LCURLY = 256;
	int RCURLY = 257;
	int STRING = 258;
	int QUESTION = 259;
	// "asdfaslkdjfa;sljdf;alskjfd;aslkjdf;ajlsdf" = 260
	int LNOT = 261;
	int BNOT = 262;
	int BAND = 263;
	int RNAND = 264;
	int BOR = 265;
	int RNOR = 266;
	int BXOR = 267;
	int RXNOR = 268;
	int STAR = 269;
	int DIV = 270;
	int MOD = 271;
	int EQUAL = 272;
	int NOT_EQ = 273;
	int EQ_CASE = 274;
	int NOT_EQ_CASE = 275;
	int LAND = 276;
	int LOR = 277;
	int LT_ = 278;
	int LE = 279;
	int GT = 280;
	int GE = 281;
	int BXNOR = 282;
	int SR = 283;
	int SL = 284;
	int SRS = 285;
	int SLS = 286;
	int POW = 287;
	int PLUSPLUS = 288;
	int MINMIN = 289;
	int DOUBLECOLON = 290;
	int LITERAL_int = 291;
	int ESCAPED_IDENTIFIER = 292;
	int DOLLAR_IDENTIFIER = 293;
	int AT = 294;
	int LITERAL_iff = 295;
	int LITERAL_s = 296;
	int LITERAL_ms = 297;
	int LITERAL_us = 298;
	int LITERAL_ns = 299;
	int LITERAL_ps = 300;
	int LITERAL_fs = 301;
	int LITERAL_step = 302;
	int TICKTICK = 303;
	int TICKQUOTE = 304;
	int CASTPAREN = 305;
	int CASTCURLY = 306;
	int ESCAPE_NEWLINE = 307;
	int ESC = 308;
	int HEX_DIGIT = 309;
	int DEFINE = 310;
	int VOCAB = 311;
	int SIZED_NUMBER = 312;
	int SIZE = 313;
	int BASE = 314;
	int SIZED_DIGIT = 315;
	int UNSIZED_NUMBER = 316;
	int DIGIT = 317;
	int HEXDIGIT = 318;
	int EXPONENT = 319;
	int WS_ = 320;
	int NEWLINE_ = 321;
	int SL_COMMENT = 322;
	int ML_COMMENT = 323;
	int OTHER_SPECIAL_CHARACTER = 324;
}
